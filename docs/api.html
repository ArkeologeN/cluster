<html>
  <head>
    <title>Cluster - extensible multi-core server management for nodejs</title>
    <link rel='stylesheet' href='../main.css' />
  </head>
  <body class="subpage">
    <div id="content"><div class='mp'>
<h2 id="API">API</h2>

<p> The Cluster API at its core is extremely simple, all we need to do is pass
 our http <code>server</code> to <code>cluster()</code>, then call <code>listen()</code> as we would on the <code>http.Server</code> itself.</p>

<pre><code> var cluster = require('../')
   , http = require('http');

 var server = http.createServer(function(req, res){
   res.writeHead(200);
   res.end('Hello World');
 });

 cluster(server)
   .listen(3000);
</code></pre>

<h3 id="Plugins">Plugins</h3>

<p> A plugin simple a function that accepts the <code>master</code> process. Most plugin functions <em>return</em> another anonymous function, allowing them to accept options, for example:</p>

<pre><code>function myPlugin(path){
  return function(master) {
    // do stuff
  }
}
</code></pre>

<p> To use them, all we need to do is pass it to the <code>use()</code> method:</p>

<pre><code>cluster(server)
  .use(myPlugin('/some/path'))
  .listen(3000);
</code></pre>

<p> To use a plugin that is bundled with Cluster simply grab it from the <code>cluster</code> object:</p>

<pre><code> cluster(server)
   .use(cluster.logger())
   .listen(3000);
</code></pre>

<h3 id="Settings">Settings</h3>

<p> Below are the settings available:</p>

<ul>
<li> <code>workers</code>  Number of workers to spawn, defaults to the number of CPUs or <code>1</code></li>
<li> <code>working directory</code>  Working directory defaulting to <code>/</code></li>
<li> <code>backlog</code>  Connection backlog, defaulting to 128</li>
<li> <code>socket path</code>  Master socket path defaulting to <code>./</code></li>
<li> <code>timeout</code> Worker shutdown timeout in milliseconds, defaulting to <code>60000</code></li>
<li> <code>user</code>  User id / name</li>
<li> <code>group</code>  Group id / name</li>
</ul>


<p> We can take what we have now, and go on to apply settings using the <code>set(option, value)</code> method. For example:</p>

<pre><code>cluster(server)
  .set('working directory', '/')
  .set('workers', 5)
  .listen(3000);
</code></pre>

<h3 id="Signals">Signals</h3>

<p> Cluster performs the following actions when handling signals:</p>

<ul>
<li> <code>SIGINT</code>   hard shutdown</li>
<li> <code>SIGTERM</code>  hard shutdown</li>
<li> <code>SIGQUIT</code>  graceful shutdown</li>
<li> <code>SIGUSR2</code>  restart workers</li>
<li> <code>SIGHUP</code>   restart workers</li>
</ul>


<h3 id="Events">Events</h3>

<p> The following events are emitted, useful for plugins or general purpose logging etc.</p>

<ul>
<li> <code>start</code>. When the server is starting (pre-spawn)</li>
<li> <code>worker</code>. When a worker is spawned, passing the <code>worker</code></li>
<li> <code>listening</code>. When the server is listening for connections (post-spawn)</li>
<li> <code>closing</code>. When master is gracefully shutting down</li>
<li> <code>close</code>. When master has completed shutting down</li>
<li> <code>worker killed</code>. When a worker has died</li>
<li> <code>kill</code>. When a <code>signal</code> is being sent to all workers</li>
<li> <code>restarting</code>. Restart requested by REPL or signal. Receives an object
 which can be patched in order to preserve plugin state.</li>
<li> <code>restart</code>. Restart complete, new master established, previous killed.
 Receives an object with state preserved by the <code>restarting</code> even,
 patched in the previous master.</li>
</ul>


<h3 id="Master-state">Master#state</h3>

<p> Current state of the master process, one of:</p>

<ul>
<li> <code>active</code></li>
<li> <code>hard shutdown</code></li>
<li> <code>graceful shutdown</code></li>
</ul>


<h3 id="Master-isWorker">Master#isWorker</h3>

<p> <code>true</code> when the script is executed as a worker.</p>

<pre><code>  cluster = cluster(server).listen(3000);

  if (cluster.isWorker) {
    // do something
  }
</code></pre>

<h3 id="Master-isMaster">Master#isMaster</h3>

<p><code>true</code> when the script is executed as master.</p>

<pre><code> cluster = cluster(server).listen(3000);

 if (cluster.isMaster) {
   // do something
 }
</code></pre>

<h3 id="Master-set-option-value-">Master#set(option, value)</h3>

<p>  Set <code>option</code> to <code>value</code>.</p>

<h3 id="Master-use-plugin-">Master#use(plugin)</h3>

<p>  Register a <code>plugin</code> for use.</p>

<h3 id="Master-in-env-">Master#in(env)</h3>

<p> Conditionally perform the following action, if
 <strong>NODE_ENV</strong> matches <code>env</code>.</p>

<pre><code> cluster(server)
   .in('development').use(cluster.debug())
   .in('development').listen(3000)
   .in('production').listen(80);
</code></pre>

<p> The environment conditionals may be applied to several calls:</p>

<pre><code> cluster(server)
   .set('working directory', '/')
   .in('development')
     .set('workers', 1)
     .use(cluster.logger('logs', 'debug'))
     .use(cluster.debug())
     .listen(3000)
   .in('production')
     .set('workers', 4)
     .use(cluster.logger())
     .use(cluster.pidfiles())
     .listen(80);
</code></pre>

<h3 id="Master-spawn-n-">Master#spawn(n)</h3>

<p>  Spawn <code>n</code> additional workers.</p>

<h3 id="Master-close-">Master#close()</h3>

<p>  Graceful shutdown, waits for all workers to reply before exiting.</p>

<h3 id="Master-destroy-">Master#destroy()</h3>

<p>  Hard shutdown, immediately kill all workers.</p>

<h3 id="Master-restart-signal-">Master#restart([signal])</h3>

<p>  Defaults to a graceful restart, spawning a new master process, and sending <strong>SIGQUIT</strong> to the previous master process. Alternatively a custom <code>signal</code> may be passed.</p>

<h3 id="Master-kill-signal-">Master#kill([signal])</h3>

<p> Sends <strong>SIGTERM</strong> or <code>signal</code> to all worker processes. This method is used by <code>Master#restart()</code>, <code>Master#close()</code> etc.</p>

</div>
    </div>
  </body>
</html>